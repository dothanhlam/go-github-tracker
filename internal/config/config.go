package config

import (
	"context"
	"encoding/json"
	"fmt"
	"os"
	"strings"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/config"
	"github.com/aws/aws-sdk-go-v2/service/secretsmanager"
	"github.com/joho/godotenv"
)

// TeamMemberConfig represents a team member configuration
type TeamMemberConfig struct {
	Username   string  `json:"username"`
	Allocation float64 `json:"allocation"`
}

// TeamConfig represents a team configuration
// Team IDs are auto-generated by the database based on the unique team name
type TeamConfig struct {
	Name    string             `json:"name"`
	Members []TeamMemberConfig `json:"members"`
}

// Config holds all application configuration
type Config struct {
	// Database configuration
	DBDriver string // "sqlite3" or "postgres"
	DBURL    string

	// GitHub configuration
	GitHubPAT string

	// Collection configuration
	LookbackDays int // Number of days to look back for PR collection

	// Team configuration
	Teams []TeamConfig

	// Repositories to track
	Repositories []string
}

// dbSecret is the JSON structure stored in Secrets Manager for DB credentials
type dbSecret struct {
	Username string `json:"username"`
	Password string `json:"password"`
}

// Load loads configuration from environment variables.
// When running in AWS Lambda:
//   - DB credentials are fetched from Secrets Manager using DB_SECRET_ARN
//   - GitHub PAT is fetched from Secrets Manager using GITHUB_PAT_SECRET_ARN
//   - The Postgres DSN is constructed from DB_HOST, DB_NAME, and the fetched credentials
//
// When running locally:
//   - Loads from .env.{APP_ENV} (default: .env.local)
//   - Falls back to DB_URL and GITHUB_PAT env vars directly
func Load() (*Config, error) {
	// Get the environment (default to "local")
	env := getEnv("APP_ENV", "local")

	// Try to load environment-specific file first
	envFile := fmt.Sprintf(".env.%s", env)
	if err := godotenv.Load(envFile); err != nil {
		// If environment-specific file doesn't exist, try .env (production only)
		if env == "production" {
			if err := godotenv.Load(".env"); err != nil {
				// Ignore error if .env doesn't exist (use system env vars)
				fmt.Printf("Warning: No .env file found, using system environment variables\n")
			}
		} else {
			// For non-production, warn if environment file is missing
			fmt.Printf("Warning: %s not found, using system environment variables\n", envFile)
		}
	} else {
		fmt.Printf("Loaded configuration from %s\n", envFile)
	}

	cfg := &Config{
		DBDriver:     getEnv("DB_DRIVER", "sqlite3"),
		DBURL:        getEnv("DB_URL", ""),
		GitHubPAT:    getEnv("GITHUB_PAT", ""),
		LookbackDays: getEnvInt("COLLECTION_LOOKBACK_DAYS", 90),
	}

	// --- Resolve credentials from AWS Secrets Manager (Lambda path) ---
	dbSecretARN := getEnv("DB_SECRET_ARN", "")
	githubPatSecretARN := getEnv("GITHUB_PAT_SECRET_ARN", "")

	if dbSecretARN != "" || githubPatSecretARN != "" {
		awsCfg, err := config.LoadDefaultConfig(context.Background())
		if err != nil {
			return nil, fmt.Errorf("failed to load AWS config: %w", err)
		}
		smClient := secretsmanager.NewFromConfig(awsCfg)

		// Fetch DB credentials from Secrets Manager
		if dbSecretARN != "" && cfg.DBURL == "" {
			creds, err := fetchSecret(smClient, dbSecretARN)
			if err != nil {
				return nil, fmt.Errorf("failed to fetch DB secret: %w", err)
			}
			var dbCreds dbSecret
			if err := json.Unmarshal([]byte(creds), &dbCreds); err != nil {
				return nil, fmt.Errorf("failed to parse DB secret JSON: %w", err)
			}

			dbHost := getEnv("DB_HOST", "")
			dbName := getEnv("DB_NAME", "dora_metrics")
			if dbHost == "" {
				return nil, fmt.Errorf("DB_HOST must be set when using DB_SECRET_ARN")
			}
			// Build a postgres DSN from the fetched credentials
			// DB_HOST from RDS includes the port (host:5432), so split it out
			host := dbHost
			port := "5432"
			if idx := strings.LastIndex(dbHost, ":"); idx != -1 {
				host = dbHost[:idx]
				port = dbHost[idx+1:]
			}
			cfg.DBURL = fmt.Sprintf(
				"host=%s port=%s user=%s password=%s dbname=%s sslmode=require",
				host, port, dbCreds.Username, dbCreds.Password, dbName,
			)
			cfg.DBDriver = "postgres"
			fmt.Printf("✓ DB credentials fetched from Secrets Manager\n")
		}

		// Fetch GitHub PAT from Secrets Manager
		if githubPatSecretARN != "" && cfg.GitHubPAT == "" {
			pat, err := fetchSecret(smClient, githubPatSecretARN)
			if err != nil {
				return nil, fmt.Errorf("failed to fetch GitHub PAT secret: %w", err)
			}
			cfg.GitHubPAT = strings.TrimSpace(pat)
			fmt.Printf("✓ GitHub PAT fetched from Secrets Manager\n")
		}
	}

	// Fallback to SQLite default only if still no DB_URL and driver is sqlite3
	if cfg.DBURL == "" && cfg.DBDriver == "sqlite3" {
		cfg.DBURL = "./data/dora_metrics.db"
	}

	// Parse team configuration
	teamConfigJSON := getEnv("TEAM_CONFIG_JSON", "[]")
	if err := json.Unmarshal([]byte(teamConfigJSON), &cfg.Teams); err != nil {
		return nil, fmt.Errorf("failed to parse TEAM_CONFIG_JSON: %w", err)
	}

	// Parse repositories
	reposStr := getEnv("REPOSITORIES", "")
	if reposStr != "" {
		cfg.Repositories = strings.Split(reposStr, ",")
		for i := range cfg.Repositories {
			cfg.Repositories[i] = strings.TrimSpace(cfg.Repositories[i])
		}
	}

	// Validate configuration
	if err := cfg.Validate(); err != nil {
		return nil, err
	}

	return cfg, nil
}

// fetchSecret retrieves a secret value from AWS Secrets Manager
func fetchSecret(client *secretsmanager.Client, arn string) (string, error) {
	out, err := client.GetSecretValue(context.Background(), &secretsmanager.GetSecretValueInput{
		SecretId: aws.String(arn),
	})
	if err != nil {
		return "", err
	}
	if out.SecretString == nil {
		return "", fmt.Errorf("secret %s has no string value", arn)
	}
	return *out.SecretString, nil
}

// Validate validates the configuration
func (c *Config) Validate() error {
	if c.DBDriver != "sqlite3" && c.DBDriver != "postgres" {
		return fmt.Errorf("DB_DRIVER must be 'sqlite3' or 'postgres', got: %s", c.DBDriver)
	}

	if c.DBURL == "" {
		return fmt.Errorf("DB_URL is required (or set DB_SECRET_ARN + DB_HOST + DB_NAME for AWS Lambda)")
	}

	// GitHub PAT is optional for now (can be added later)
	// if c.GitHubPAT == "" {
	// 	return fmt.Errorf("GITHUB_PAT is required")
	// }

	return nil
}

// getEnv gets an environment variable or returns a default value
func getEnv(key, defaultValue string) string {
	if value := os.Getenv(key); value != "" {
		return value
	}
	return defaultValue
}

// getEnvInt gets an integer environment variable or returns a default value
func getEnvInt(key string, defaultValue int) int {
	if value := os.Getenv(key); value != "" {
		var intValue int
		if _, err := fmt.Sscanf(value, "%d", &intValue); err == nil {
			return intValue
		}
	}
	return defaultValue
}
