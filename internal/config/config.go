package config

import (
	"encoding/json"
	"fmt"
	"os"
	"strings"

	"github.com/joho/godotenv"
)

// TeamMemberConfig represents a team member configuration
type TeamMemberConfig struct {
	Username   string  `json:"username"`
	Allocation float64 `json:"allocation"`
}

// TeamConfig represents a team configuration
// Team IDs are auto-generated by the database based on the unique team name
type TeamConfig struct {
	Name    string             `json:"name"`
	Members []TeamMemberConfig `json:"members"`
}

// Config holds all application configuration
type Config struct {
	// Database configuration
	DBDriver string // "sqlite3" or "postgres"
	DBURL    string

	// GitHub configuration
	GitHubPAT string

	// Collection configuration
	LookbackDays int // Number of days to look back for PR collection

	// Team configuration
	Teams []TeamConfig

	// Repositories to track
	Repositories []string
}

// Load loads configuration from environment variables
// It first attempts to load from an environment-specific .env file
// Environment files are loaded in this order:
// 1. .env.{APP_ENV} (e.g., .env.local, .env.test, .env.production)
// 2. .env (fallback, production only)
//
// Default APP_ENV is "local" if not set
func Load() (*Config, error) {
	// Get the environment (default to "local")
	env := getEnv("APP_ENV", "local")

	// Try to load environment-specific file first
	envFile := fmt.Sprintf(".env.%s", env)
	if err := godotenv.Load(envFile); err != nil {
		// If environment-specific file doesn't exist, try .env (production only)
		if env == "production" {
			if err := godotenv.Load(".env"); err != nil {
				// Ignore error if .env doesn't exist (use system env vars)
				fmt.Printf("Warning: No .env file found, using system environment variables\n")
			}
		} else {
			// For non-production, warn if environment file is missing
			fmt.Printf("Warning: %s not found, using system environment variables\n", envFile)
		}
	} else {
		fmt.Printf("Loaded configuration from %s\n", envFile)
	}

	cfg := &Config{
		DBDriver:     getEnv("DB_DRIVER", "sqlite3"),
		DBURL:        getEnv("DB_URL", "./data/dora_metrics.db"),
		GitHubPAT:    getEnv("GITHUB_PAT", ""),
		LookbackDays: getEnvInt("COLLECTION_LOOKBACK_DAYS", 90),
	}

	// Parse team configuration
	teamConfigJSON := getEnv("TEAM_CONFIG_JSON", "[]")
	if err := json.Unmarshal([]byte(teamConfigJSON), &cfg.Teams); err != nil {
		return nil, fmt.Errorf("failed to parse TEAM_CONFIG_JSON: %w", err)
	}

	// Parse repositories
	reposStr := getEnv("REPOSITORIES", "")
	if reposStr != "" {
		cfg.Repositories = strings.Split(reposStr, ",")
		for i := range cfg.Repositories {
			cfg.Repositories[i] = strings.TrimSpace(cfg.Repositories[i])
		}
	}

	// Validate configuration
	if err := cfg.Validate(); err != nil {
		return nil, err
	}

	return cfg, nil
}

// Validate validates the configuration
func (c *Config) Validate() error {
	if c.DBDriver != "sqlite3" && c.DBDriver != "postgres" {
		return fmt.Errorf("DB_DRIVER must be 'sqlite3' or 'postgres', got: %s", c.DBDriver)
	}

	if c.DBURL == "" {
		return fmt.Errorf("DB_URL is required")
	}

	// GitHub PAT is optional for now (can be added later)
	// if c.GitHubPAT == "" {
	// 	return fmt.Errorf("GITHUB_PAT is required")
	// }

	return nil
}

// getEnv gets an environment variable or returns a default value
func getEnv(key, defaultValue string) string {
	if value := os.Getenv(key); value != "" {
		return value
	}
	return defaultValue
}

// getEnvInt gets an integer environment variable or returns a default value
func getEnvInt(key string, defaultValue int) int {
	if value := os.Getenv(key); value != "" {
		var intValue int
		if _, err := fmt.Sscanf(value, "%d", &intValue); err == nil {
			return intValue
		}
	}
	return defaultValue
}
